/*
 * Copyright (c) 2014, Pierre-Yves Martin
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include "codegenerator.h"

#include "llvm/Support/TargetSelect.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/JIT.h" /* needed to prevent "Interpreter has not been linked in" when creating JIT engine */
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"

#include <iostream>

#include "ast.h"
#include "parser.h"

Code::Code() :
    codeIR(),
    execEngineJIT()
{}

bool Code::setCodeIR(llvm::Value* ir) {
    if (codeIR != nullptr) {
        return Error("Code Intermediary Representation already set.");
    }

    codeIR = ir;
    return true;
}

bool Code::createJIT(llvm::Module* module) {
    if (execEngineJIT != nullptr) {
        return Error("execution engine already initialised. CreateJIT must be called only once");
    }

    // create a JIT Engine (This takes ownership of the module).
    std::string errStr;
    execEngineJIT = llvm::EngineBuilder(module).setErrorStr(&errStr).setEngineKind(llvm::EngineKind::JIT).create(); // TODO explode this loooooong line
    if (execEngineJIT == nullptr) {
        return Error("Can't get an LLVM JIT execution engine : " + errStr);
    }

    return true;
}

bool Code::run(float& result) {
    if (execEngineJIT == nullptr) {
        return Error("No execution engine available, createJIT() must be called before any run().");
    }

    if (codeIR == nullptr) {
        return Error("No execution code IR available, the code IR should be generated by CodeGenerator.codegen().");
    }

    // TODO change code attribute type to llvm::Function* to avoid this conversion
    // Convert generic code to anonymous function code
    llvm::Function* funcCode = static_cast<llvm::Function*>(codeIR);

    // No arguments for the function
    const std::vector<llvm::GenericValue> noArgs = std::vector<llvm::GenericValue>();

    // TODO test the result of runFunction
    result = execEngineJIT->runFunction(funcCode, noArgs).FloatVal;
    return true;
}

bool Code::Error(const std::string msg) {
    std::cerr << "[CODE ERROR] " << msg << std::endl;

    return false;
}

NewCodeGenerator::NewCodeGenerator(AbstractSyntaxTree& theAst, Code& theCode) :
    ast(theAst),
    code(theCode),
    symbolTable(),
    module(nullptr),
    builder(llvm::getGlobalContext())
{}

bool NewCodeGenerator::init() {
    // Make the module, which holds all the code
    llvm::InitializeNativeTarget();
    llvm::LLVMContext& context = llvm::getGlobalContext();

    module = new llvm::Module("MeeMaw module", context);

    if (module == nullptr) {
        return Error("Can't get a module.");
    }

    return true;
}

bool NewCodeGenerator::codegen() {
    if (not code.createJIT(module)) {
        return Error("Can't initialise code before generation.");
    }

    llvm::Value* codeIR = ast.codegen(this);
    if (codeIR == nullptr) {
        return Error("No code generated from AST.");
    }

    code.setCodeIR(codeIR);
    return true;
}

llvm::Module* NewCodeGenerator::getModule() const {
    return module;
}

llvm::IRBuilder<>& NewCodeGenerator::getBuilder() {
    return builder;
}

std::map<std::string, llvm::Value*>& NewCodeGenerator::getSymbolTable() {
    return symbolTable;
}

bool NewCodeGenerator::Error(const std::string msg) {
    std::cerr << "[CODE GENERATOR ERROR] " << msg << std::endl;

    return false;
}
